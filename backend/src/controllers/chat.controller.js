import { Conversation } from "../models/conversation.model.js";
import { User } from "../models/user.model.js";
import { Billing } from "../models/billing.model.js";
import { aiModel } from "../utils/aiModel.js";

export const getAllConversation = async (req, res) => {
    try {
        const { userId } = req.body; // Assuming userId is sent in the request body
        if (!userId) {
            return res.status(400).json({ 
                data: {}, 
                status: 400, 
                message: "User ID is required" 
            });
        }

        // Fetch the user from the database
        const user = await User.findById(userId).populate('conversations'); // Adjust based on your schema

        if (!user) {
            return res.status(404).json({
                data: {},
                status: 404,
                message: "User not found"
            });
        }

      
        

        res.status(200).json({ 
            data: { conversations: user.conversations }, 
            message: "Conversations fetched successfully", 
            status: 200 
        });

    } catch (error) {
        console.error("Error fetching all conversations", error);
        res.status(500).json({ 
            data: {}, 
            status: 500, 
            message: "Error fetching conversations" 
        });
    }
};


export const getParticulartConversation = async (req, res) => {
    try {
        const { websiteName } = req.body;

        if (!websiteName) {
            return res.status(400).json({ data: {}, status: 400, message: "Website name is required" })
        }

        const conversations = req.user.conversations;

        const conversation = conversations.find(conv => conv.websiteName === websiteName);

        if (!conversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Particular Conversation not found" })
        }

        res.status(200).json({ data: { conversation }, message: "Conversation fetched successfully", status: 200 });

    } catch (error) {
        console.error("Error fetching all conversations", error);
        res.status(400).json({ data: {}, status: 400, message: "Error fetching conversations" });
    }
}

// there is no need for this, as if the conversation does not exist, we will create it in addChat function only
export const addNewConversation = async (req, res) => {
    try {
        const { websiteName } = req.body;

        if (!websiteName) {
            return res.status(400).json({ data: {}, status: 400, message: "Website name is required" })
        }

        const addNewConversation = await Conversation.create({ websiteName });

        if (!addNewConversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" })
        }

        const updatedUserWithNewConversation = await User.findOneAndUpdate({ _id: req.user._id }, { $push: { conversations: addNewConversation._id } }, { new: true }).populate({
            path: "conversations",
        }).select("-password").exec();

        if (!updatedUserWithNewConversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" })
        }

        res.status(200).json({ data: { updatedUserWithNewConversation }, message: "Conversation added successfully", status: 200 });

    } catch (error) {
        console.error("Error adding new conversation", error);
        res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" });
    }
}

export const addNewChatsToConversation = async (req, res) => {
    try {
        const { websiteName, question, model,extraInfo } = req.body; // question, answer, timestamp, model   

      
        if (!websiteName || !question ) {
            return res.status(400).json({ data: {}, status: 400, message: "Website name, question are required; only model is optional." });
        }

        let answer = await aiModel.generateContent(question+extraInfo)  ;
        console.log("answer", JSON.stringify(answer)) ;
        console.log("answer type", typeof answer) ;
        answer = answer.response.candidates[0].content.parts[0].text
        // const answer = "this is the answer generated by AI";

        // const answer="Blockchain is a shared, immutable ledger that facilitates the process of recording and verifying transactions and data in a secure, transparent, and efficient way.  Think of it as a digital record-keeping system that's distributed across many computers (nodes) instead of being stored in a single location.\n\nHere's a breakdown of key aspects:\n\n* **Shared:**  The ledger is not controlled by a single entity, but rather distributed across a network of computers.  This decentralization makes it more resistant to manipulation or censorship.\n\n* **Immutable:** Once a transaction is recorded on the blockchain, it cannot be altered or deleted. This ensures data integrity and trustworthiness.\n\n* **Transparent:** All transactions are visible to anyone on the network, although participants may be pseudonymous (using addresses instead of names).  This transparency enhances accountability.\n\n* **Secure:**  Cryptographic hashing and consensus mechanisms (like Proof-of-Work or Proof-of-Stake) protect the blockchain from fraudulent activities.  These mechanisms ensure that only valid transactions are added to the chain.\n\n* **Decentralized:** No single person or organization controls the blockchain.  This makes it resistant to single points of failure and censorship.\n\n**How it works (simplified):**\n\n1. **Transaction:** A transaction (e.g., a cryptocurrency transfer or any other data) is initiated.\n2. **Verification:** The transaction is broadcast to the network.\n3. **Validation:** Nodes on the network verify the transaction's validity using cryptographic techniques.\n4. **Block Creation:** Verified transactions are grouped into \"blocks.\"\n5. **Chain Addition:** The new block is added to the existing chain of blocks, creating a chronological record.\n6. **Consensus:** A consensus mechanism ensures that all nodes agree on the valid state of the blockchain.\n\n**Use Cases beyond Cryptocurrency:**\n\nWhile Bitcoin popularized blockchain, its applications extend far beyond digital currencies.  These include:\n\n* **Supply chain management:** Tracking goods from origin to consumer, enhancing transparency and preventing counterfeiting.\n* **Healthcare:** Securely storing and sharing patient medical records.\n* **Voting systems:** Creating tamper-proof and auditable voting systems.\n* **Digital identity:** Managing and verifying digital identities.\n* **Intellectual property protection:** Registering and verifying ownership of intellectual property.\n\n**Limitations:**\n\n* **Scalability:**  Processing large numbers of transactions can be slow and expensive on some blockchains.\n* **Energy consumption:**  Some consensus mechanisms (like Proof-of-Work) are energy-intensive.\n* **Regulation:** The regulatory landscape surrounding blockchain technology is still evolving.\n* **Complexity:**  The underlying technology can be complex to understand and implement.\n\n\nIn essence, blockchain is a revolutionary technology with the potential to transform numerous industries by providing a secure, transparent, and efficient way to manage data and transactions.\n"


        const timestamp = new Date();

        // Find the user's conversation with the specified websiteName
        const existingUser = req.user;

        const userBilling = await Billing.findOne({ user: existingUser._id });

        if (!userBilling) {
            return res.status(400).json({ data: {}, status: 400, message: "Billing information not found for this user." });
        }

        // Check if the user has at least 5 tokens
        if (userBilling.token < 5) {
            return res.status(400).json({ data: {}, status: 400, message: "Not enough tokens. You need at least 5 tokens to perform this action." });
        }

        // Deduct 5 tokens from the user's billing
        userBilling.token -= 5;
        await userBilling.save();
        
        

        // Find the conversation by websiteName among the user's conversations
        let conversation = existingUser.conversations.find(conv => conv.websiteName === websiteName);

        

        if (!conversation) {
            const addNewConversation = await Conversation.create(
                {
                    websiteName,
                    chats: [
                        { question, answer, timestamp, model }
                    ]
                });

            if (!addNewConversation) {
                return res.status(400).json({ data: {}, status: 400, message: "While adding chat, we were making new conversation but some error occured" })
            }

            const updatedUserWithNewConversation = await User.findOneAndUpdate({ _id: existingUser._id }, { $push: { conversations: addNewConversation._id } }, { new: true }).populate({
                path: "conversations",
            }).select("-password").exec();

            if (!updatedUserWithNewConversation) {
                return res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" })
            }

            const ansObj = addNewConversation ;
            console.log("new conversation created", JSON.stringify(ansObj)) ;

            ansObj.chats = ansObj.chats?.filter(chat => chat.timestamp.getTime() === timestamp.getTime())

          

            return res.status(200).json({ data: { conversation: ansObj }, message: "Conversation added successfully", status: 200 });


        }

        // Add the new chat directly to the Conversation model
        const updatedConversation = await Conversation.findByIdAndUpdate(
            conversation._id,
            { $push: { chats: { question, answer, timestamp, model } } },
            { new: true }
        );

        if (!updatedConversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Error adding new chat to the conversation." });
        }
        
        const ansObj = updatedConversation
        ansObj.chats = ansObj.chats.filter(chat => chat.timestamp.getTime() === timestamp.getTime())


        res.status(200).json({ data: { conversation: ansObj }, message: "Conversation updated successfully", status: 200 });

    } catch (error) {
        console.error("Error adding new chat to conversation", error);
        res.status(500).json({ data: {}, status: 500, message: "Server error adding new chat to conversation" });
    }
};

