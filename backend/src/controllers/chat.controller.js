import { Conversation } from "../models/conversation.model.js";
import { User } from "../models/user.model.js";
import { Billing } from "../models/billing.model.js";
import { aiModel } from "../utils/aiModel.js";

export const getAllConversation = async (req, res) => {
    try {
        const { userId } = req.body; // Assuming userId is sent in the request body
        if (!userId) {
            return res.status(400).json({ 
                data: {}, 
                status: 400, 
                message: "User ID is required" 
            });
        }

        // Fetch the user from the database
        const user = await User.findById(userId).populate('conversations'); // Adjust based on your schema

        if (!user) {
            return res.status(404).json({
                data: {},
                status: 404,
                message: "User not found"
            });
        }

      
        

        res.status(200).json({ 
            data: { conversations: user.conversations }, 
            message: "Conversations fetched successfully", 
            status: 200 
        });

    } catch (error) {
        console.error("Error fetching all conversations", error);
        res.status(500).json({ 
            data: {}, 
            status: 500, 
            message: "Error fetching conversations" 
        });
    }
};


export const getParticulartConversation = async (req, res) => {
    try {
        const { websiteName } = req.body;

        if (!websiteName) {
            return res.status(400).json({ data: {}, status: 400, message: "Website name is required" })
        }

        const conversations = req.user.conversations;

        const conversation = conversations.find(conv => conv.websiteName === websiteName);

        if (!conversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Particular Conversation not found" })
        }

        res.status(200).json({ data: { conversation }, message: "Conversation fetched successfully", status: 200 });

    } catch (error) {
        console.error("Error fetching all conversations", error);
        res.status(400).json({ data: {}, status: 400, message: "Error fetching conversations" });
    }
}

// there is no need for this, as if the conversation does not exist, we will create it in addChat function only
export const addNewConversation = async (req, res) => {
    try {
        const { websiteName } = req.body;

        if (!websiteName) {
            return res.status(400).json({ data: {}, status: 400, message: "Website name is required" })
        }

        const addNewConversation = await Conversation.create({ websiteName });

        if (!addNewConversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" })
        }

        const updatedUserWithNewConversation = await User.findOneAndUpdate({ _id: req.user._id }, { $push: { conversations: addNewConversation._id } }, { new: true }).populate({
            path: "conversations",
        }).select("-password").exec();

        if (!updatedUserWithNewConversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" })
        }

        res.status(200).json({ data: { updatedUserWithNewConversation }, message: "Conversation added successfully", status: 200 });

    } catch (error) {
        console.error("Error adding new conversation", error);
        res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" });
    }
}

export const addNewChatsToConversation = async (req, res) => {
    try {
        const { websiteName, question, model, extraInfo = "" } = req.body; // question, answer, timestamp, model   

      
        if (!websiteName || !question ) {
            return res.status(400).json({ data: {}, status: 400, message: "Website name, question are required; only model is optional." });
        }

        // let answer = await aiModel.generateContent(question+extraInfo)  ;
        // console.log("answer", JSON.stringify(answer)) ;
        // console.log("answer type", typeof answer) ;
        // answer = answer.response.candidates[0].content.parts[0].text
        const answer = "this is the answer generated by AI";

//         const answer=```Binary search is a highly efficient algorithm for finding a specific item within a sorted list or array. It works by repeatedly dividing the search interval in half. If the target value is less than the middle element, the search continues in the lower half; otherwise, it continues in the upper half. This process is repeated until the target value is found or the search interval is empty.

// Here's a breakdown of how it works:

// Sorted Data: Binary search requires the data to be sorted in ascending order (from smallest to largest). If your data isn't sorted, you'll need to sort it first (using an algorithm like merge sort or quicksort) before applying binary search.

// Find the Middle: Start by finding the middle element of the search interval. The interval initially encompasses the entire list.

// Compare: Compare the target value with the middle element:

// Target == Middle: If they are equal, the search is successful, and the algorithm returns the index (position) of the target value.
// Target < Middle: If the target value is less than the middle element, the target must be in the lower half of the list. Discard the upper half and repeat the process on the lower half.
// Target > Middle: If the target value is greater than the middle element, the target must be in the upper half of the list. Discard the lower half and repeat the process on the upper half.
// Repeat: Continue steps 2 and 3 until the target value is found or the search interval becomes empty (meaning the target value is not present in the list).

// Example:

// Let's say we have a sorted list: [2, 5, 7, 8, 11, 12] and we want to search for the value 11.

// Initial interval: [2, 5, 7, 8, 11, 12]
// Middle element: 8 (index 3)
// Comparison: 11 > 8, so we discard the lower half [2, 5, 7] and continue with the upper half.
// New interval: [8, 11, 12]
// Middle element: 11 (index 1 in the new interval, index 4 in the original list)
// Comparison: 11 == 11, the search is successful! The algorithm returns the index 4 (or 1 depending on how you implement it).
// Implementation (Python):

// def binary_search(arr, target):
//   """
//   Performs a binary search on a sorted list.

//   Args:
//     arr: The sorted list to search.
//     target: The value to search for.

//   Returns:
//     The index of the target value if found, otherwise -1.
//   """
//   low = 0
//   high = len(arr) - 1

//   while low <= high:
//     mid = (low + high) // 2  # Integer division to find the middle index

//     if arr[mid] == target:
//       return mid  # Target found
//     elif arr[mid] < target:
//       low = mid + 1  # Search in the upper half
//     else:
//       high = mid - 1  # Search in the lower half

//   return -1  # Target not found


// # Example usage:
// sorted_list = [2, 5, 7, 8, 11, 12]
// target_value = 11
// index = binary_search(sorted_list, target_value)

// if index != -1:
//   print(f"Target found at index: {index}")
// else:
//   print("Target not found")
// Time Complexity: O(log n) - The search space is halved in each iteration, making it very efficient for large datasets.

// Space Complexity: O(1) - Binary search uses a constant amount of extra space regardless of the input size. It's an in-place algorithm.

//         Remember, the crucial requirement for binary search is that the input data must be sorted. If it's not, the algorithm will not work correctly.\n```

//         console.log("Answer type", typeof answer) ;


        const timestamp = new Date();

        // Find the user's conversation with the specified websiteName
        const existingUser = req.user;

        const userBilling = await Billing.findOne({ user: existingUser._id });

        if (!userBilling) {
            return res.status(400).json({ data: {}, status: 400, message: "Billing information not found for this user." });
        }

        // Check if the user has at least 5 tokens
        if (userBilling.token < 5) {
            return res.status(400).json({ data: {}, status: 400, message: "Not enough tokens. You need at least 5 tokens to perform this action." });
        }

        // Deduct 5 tokens from the user's billing
        userBilling.token -= 5;
        await userBilling.save();
        
        

        // Find the conversation by websiteName among the user's conversations
        let conversation = existingUser.conversations.find(conv => conv.websiteName === websiteName);

        

        if (!conversation) {
            const addNewConversation = await Conversation.create(
                {
                    websiteName,
                    chats: [
                        { question, answer, timestamp, model }
                    ]
                });

            if (!addNewConversation) {
                return res.status(400).json({ data: {}, status: 400, message: "While adding chat, we were making new conversation but some error occured" })
            }

            const updatedUserWithNewConversation = await User.findOneAndUpdate({ _id: existingUser._id }, { $push: { conversations: addNewConversation._id } }, { new: true }).populate({
                path: "conversations",
            }).select("-password").exec();

            if (!updatedUserWithNewConversation) {
                return res.status(400).json({ data: {}, status: 400, message: "Error adding new conversation" })
            }

            const ansObj = addNewConversation ;
            console.log("new conversation created", JSON.stringify(ansObj)) ;

            ansObj.chats = ansObj.chats?.filter(chat => chat.timestamp.getTime() === timestamp.getTime())

          

            return res.status(200).json({ data: { conversation: ansObj }, message: "Conversation added successfully", status: 200 });


        }

        // Add the new chat directly to the Conversation model
        const updatedConversation = await Conversation.findByIdAndUpdate(
            conversation._id,
            { $push: { chats: { question, answer, timestamp, model } } },
            { new: true }
        );

        if (!updatedConversation) {
            return res.status(400).json({ data: {}, status: 400, message: "Error adding new chat to the conversation." });
        }
        
        const ansObj = updatedConversation
        console.log(JSON.stringify(ansObj)) ;
        
        ansObj.chats = ansObj.chats.filter(chat => chat.timestamp.getTime() === timestamp.getTime())
        

        res.status(200).json({ data: { conversation: ansObj }, message: "Conversation updated successfully", status: 200 });

    } catch (error) {
        console.error("Error adding new chat to conversation", error);
        res.status(500).json({ data: {}, status: 500, message: "Server error adding new chat to conversation" });
    }
};

